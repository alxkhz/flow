"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[853],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3860:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={},r="Schema evolution",l={unversionedId:"guides/schema-evolution",id:"guides/schema-evolution",title:"Schema evolution",description:"How to deal with changing schemas in your materializations",source:"@site/docs/guides/schema-evolution.md",sourceDirName:"guides",slug:"/guides/schema-evolution",permalink:"/pr-preview/pr-1259/guides/schema-evolution",draft:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/guides/schema-evolution.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Customize materialized fields",permalink:"/pr-preview/pr-1259/guides/customize-materialization-fields"},next:{title:"Concepts",permalink:"/pr-preview/pr-1259/concepts/"}},s={},c=[{value:"Background",id:"background",level:2},{value:"Schema evolution scenarios",id:"schema-evolution-scenarios",level:2},{value:"Re-creating a collection",id:"re-creating-a-collection",level:3},{value:"A new field is added",id:"a-new-field-is-added",level:3},{value:"A field&#39;s data type has changed",id:"a-fields-data-type-has-changed",level:3},{value:"A field was removed",id:"a-field-was-removed",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...o}=e;return(0,i.kt)(d,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"schema-evolution"},"Schema evolution"),(0,i.kt)("p",null,"How to deal with changing schemas in your materializations"),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"Flow ",(0,i.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/collections"},"collections")," serve not only as a data storage and retrieval mechanism, but also as a contract between producers and consumers of the data. This contract is defined in terms of the collection spec, which includes the JSON schema, the ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),", and ",(0,i.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/advanced/projections"},"projections"),". This guide helps you figure out how to respond to different types of changes in the collection spec."),(0,i.kt)("h2",{id:"schema-evolution-scenarios"},"Schema evolution scenarios"),(0,i.kt)("p",null,"This guide is broken down into sections for different common scenarios, depending on which properties of the collection spec have changed."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#re-creating-a-collection"},"The ",(0,i.kt)("inlineCode",{parentName:"a"},"key")," pointers have changed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#re-creating-a-collection"},"The logical partitioning configuration has changed")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"schema")," (or ",(0,i.kt)("inlineCode",{parentName:"li"},"readSchema")," if defined separately) has changed",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A new field is added"),(0,i.kt)("li",{parentName:"ul"},"A field's data type has changed"),(0,i.kt)("li",{parentName:"ul"},"A field was removed")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"There are a variety of reasons why these properties may change, and also different mechanisms for detecting changes in source data. In general, it doesn't matter why the collection spec has changed, only ",(0,i.kt)("em",{parentName:"p"},"what")," has changed. However, ",(0,i.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/captures#AutoDiscover"},"auto-discovers")," are able to handle some of these scenarios automatically. Where applicable, auto-discover behavior will be called out under each section.")),(0,i.kt)("h3",{id:"re-creating-a-collection"},"Re-creating a collection"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," of a Flow collection cannot be changed after the collection is created. The same is true of the logical partitioning, which also cannot be changed after the collection is created. If you need to change either of those parts of a collection spec, then you'll need to create a new collection and update the bindings of any captures or materializations that reference the old collection. If you're working in the Estuary UI, then you'll see an error message and an offer to re-create the collection by clicking the \"Apply\" button, as shown in the example below."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(4244).Z,width:"2318",height:"1215"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Flowctl workflow:")),(0,i.kt)("p",null,"If you're working with flowctl, then you'll follow some different steps, but the net effect will be the same. You'll have to rename the collection in your ",(0,i.kt)("inlineCode",{parentName:"p"},"flow.yaml"),", making sure to also update any captures or materializations that reference it. For example, say you started out with the following YAML specs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"captures:\n  acmeCo/inventory/source-postgres:\n    endpoint:\n      connector:\n        image: ghcr.io/estuary/source-postgres:v1\n        config: encrypted-pg-config.sops.yaml\n    bindings:\n      - resource:\n          namespace: public\n          stream: anvils\n          mode: Normal\n        target: acmeCo/inventory/anvils\n\ncollections:\n  acmeCo/inventory/anvils:\n    key: [/sku]\n    schema:\n      type: object\n      properties:\n        sku: { type: string }\n        warehouse_id: { type: string }\n        quantity: { type: integer }\n      required: [sku, warehouse_id, quantity]\n\nmaterializations:\n  acmeCo/data-warehouse/materialize-snowflake:\n    endpoint:\n      connector:\n        image: ghcr.io/estuary/materialize-snowflake:v1\n        config: encrypted-snowflake-config.sops.yaml\n    bindings:\n      - source: acmeCo/inventory/anvils\n        resource:\n          table: anvils\n          schema: inventory\n")),(0,i.kt)("p",null,"Then to change the collection key, you would update the YAML like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"captures:\n  acmeCo/inventory/source-postgres:\n    endpoint:\n      connector:\n        image: ghcr.io/estuary/source-postgres:v1\n        config: encrypted-pg-config.sops.yaml\n    bindings:\n      - resource:\n          namespace: public\n          stream: anvils\n          mode: Normal\n        target: acmeCo/inventory/anvils_v2\n\ncollections:\n  acmeCo/inventory/anvils_v2:\n    key: [/sku]\n    schema:\n      type: object\n      properties:\n        sku: { type: string }\n        warehouse_id: { type: string }\n        quantity: { type: integer }\n      required: [sku, warehouse_id, quantity]\n\nmaterializations:\n  acmeCo/data-warehouse/materialize-snowflake:\n    endpoint:\n      connector:\n        image: ghcr.io/estuary/materialize-snowflake:v1\n        config: encrypted-snowflake-config.sops.yaml\n    bindings:\n      - source: acmeCo/inventory/anvils_v2\n        resource:\n          table: anvils_v2\n          schema: inventory\n")),(0,i.kt)("p",null,"The existing ",(0,i.kt)("inlineCode",{parentName:"p"},"acmeCo/inventory/anvils")," collection will not be modified at all by this, and will remain in place."),(0,i.kt)("p",null,"Note that the collection is now being materialized into a new table, ",(0,i.kt)("inlineCode",{parentName:"p"},"anvils_v2"),". This is because the primary key of the ",(0,i.kt)("inlineCode",{parentName:"p"},"anvils")," table doesn't match the new collection key. New data going forward will be added to ",(0,i.kt)("inlineCode",{parentName:"p"},"anvils_v2"),"."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Currently, changing the ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," collection in the capture spec will ",(0,i.kt)("em",{parentName:"p"},"not")," cause the capture to perform another backfill. This means that the ",(0,i.kt)("inlineCode",{parentName:"p"},"anvils_v2")," table will end up getting all of the ",(0,i.kt)("em",{parentName:"p"},"new")," data going forward, but will not contain the existing data from ",(0,i.kt)("inlineCode",{parentName:"p"},"anvils"),". We plan to soon release updates that make it much easier to keep your destination tables fully in-sync without needing to change the names. In the meantime, feel free to reach out on Slack for help with making this work.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Auto-Discovers:")),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"autoDiscover")," is enabled for your capture, then this re-creation of the collection can optionally be performed automatically by enabling ",(0,i.kt)("inlineCode",{parentName:"p"},"evolveIncompatibleCollections"),". Collections would only be re-created in cases where a new ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is discovered."),(0,i.kt)("h3",{id:"a-new-field-is-added"},"A new field is added"),(0,i.kt)("p",null,"When a new field appears in the collection schema, it ",(0,i.kt)("em",{parentName:"p"},"may")," automatically be added to any materializations that use ",(0,i.kt)("inlineCode",{parentName:"p"},"recommended")," fields. See ",(0,i.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/materialization#projected-fields"},"the materialization docs")," for more info about how to enable or disable ",(0,i.kt)("inlineCode",{parentName:"p"},"recommended")," fields."),(0,i.kt)("p",null,"If the materialization binding uses ",(0,i.kt)("inlineCode",{parentName:"p"},"recommended: true"),' in the field selection (it is enabled by default, if unspecified), then new fields will be added automatically if they meet the criteria for the particular materialization connector. For example, scalar fields (strings, numbers, and booleans) are considered "recommended" fields when materializing to database tables.'),(0,i.kt)("p",null,"If your materialization binding uses ",(0,i.kt)("inlineCode",{parentName:"p"},"recommended: false"),', or if the field you want is not recommended, then you can still add it to the materialization. You\'ll just need to do so explicitly. You can do so either by editing the materialization in the UI and clicking "Show Fields" on the affected binding, or else by adding it to ',(0,i.kt)("inlineCode",{parentName:"p"},"fields.include")," as shown ",(0,i.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/materialization#projected-fields"},"here"),"."),(0,i.kt)("h3",{id:"a-fields-data-type-has-changed"},"A field's data type has changed"),(0,i.kt)("p",null,"When the data type of a field has changed, the effect on your materialization depends on the specific connector you're using. Note that these restrictions only apply to fields that are actively being materialized. If a field is excluded from your materialization, either explicitly or because it's not recommended, then the data types may change in any way."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"You can still get yourself into trouble if your schema changes such that existing data is no longer valid against the new schema. For example, if you have ",(0,i.kt)("inlineCode",{parentName:"p"},"excluded_field: { type: string }")," and you change it to ",(0,i.kt)("inlineCode",{parentName:"p"},"type: integer"),", then it is likely to cause consumers of the collection to fail due to a schema validation failure, since there may be existing data with string values for that field.")),(0,i.kt)("p",null,"Database (or data warehouse) materializations tend to be somewhat restrictive about changing column types. They typically only allow dropping ",(0,i.kt)("inlineCode",{parentName:"p"},"NOT NULL")," constraints. This means that you can safely change a schema to make a required field optional, or to add ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," as a possible type, and the materialization will continue to work normally.  Most other types of changes will require materializing into a new table."),(0,i.kt)("p",null,"You can always try publishing your changes, and see if the connector allows it. If not, the publication (or test) will fail with an error message pointing to the field that's changed. In this case, you can work around the issue by simply materializing into a new table. For example, if you started out with the specs below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"collections:\n  acmeCo/inventory/anvils:\n    key: [/sku]\n    schema:\n      type: object\n      properties:\n        sku: { type: string }\n        quantity: { type: integer }\n        description: { type: string }\n      required: [sku, quantity]\n\nmaterializations:\n  acmeCo/data-warehouse/materialize-snowflake:\n    endpoint:\n      connector:\n        image: ghcr.io/estuary/materialize-snowflake:v1\n        config: encrypted-snowflake-config.sops.yaml\n    bindings:\n      - source: acmeCo/inventory/anvils\n        resource:\n          table: anvils\n          schema: inventory\n")),(0,i.kt)("p",null,"Let's say that the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"description")," is broadened to allow ",(0,i.kt)("inlineCode",{parentName:"p"},"object")," values in addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". You'd update your specs thusly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"collections:\n  acmeCo/inventory/anvils:\n    key: [/sku]\n    schema:\n      type: object\n      properties:\n        sku: { type: string }\n        quantity: { type: integer }\n        description: { type: [string, object] }\n      required: [sku, quantity]\n\nmaterializations:\n  acmeCo/data-warehouse/materialize-snowflake:\n    endpoint:\n      connector:\n        image: ghcr.io/estuary/materialize-snowflake:v1\n        config: encrypted-snowflake-config.sops.yaml\n    bindings:\n      - source: acmeCo/inventory/anvils\n        resource:\n          table: anvils_v2\n          schema: inventory\n")),(0,i.kt)("p",null,"Note that the collection name has remained the same. Only the materialization ",(0,i.kt)("inlineCode",{parentName:"p"},"resource")," is updated to write to a new table, which will backfill from the existing collection data. This works because the type is broadened, so existing values will still validate against the new schema. If this were not the case, then you'd probably want to ",(0,i.kt)("a",{parentName:"p",href:"#re-creating-a-collection"},"re-create the whole collection"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Auto-Discovers:")),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"autoDiscover")," is enabled for your capture, then materializing into a new table can optionally be performed automatically by enabling ",(0,i.kt)("inlineCode",{parentName:"p"},"evolveIncompatibleCollections"),"."),(0,i.kt)("h3",{id:"a-field-was-removed"},"A field was removed"),(0,i.kt)("p",null,"Removing fields is generally allowed by all connectors, and does not require new tables or collections. Note that for database materializations, the existing column will ",(0,i.kt)("em",{parentName:"p"},"not")," be dropped, and will just be ignored by the materialization going forward. A ",(0,i.kt)("inlineCode",{parentName:"p"},"NOT NULL")," constraint would be removed from that column, but it will otherwise be left in place."))}u.isMDXComponent=!0},4244:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/evolution-re-create-ui-d8ae2ab634980751f8c87a0483f96d39.png"}}]);