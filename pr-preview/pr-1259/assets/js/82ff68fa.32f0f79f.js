(self.webpackChunksite=self.webpackChunksite||[]).push([[8839],{1504:(e,t,a)=>{"use strict";a.d(t,{Z:()=>i});var o=a(7294),n=a(2764);n.Z.initialize({startOnLoad:!0});const i=e=>{let{chart:t}=e;return(0,o.useEffect)((()=>{n.Z.contentLoaded()}),[]),o.createElement("div",{className:"mermaid"},t)}},4112:(e,t,a)=>{"use strict";a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var o=a(7462),n=(a(7294),a(3905)),i=a(1504);const l={},r="Schema evolution",s={unversionedId:"concepts/evolutions",id:"concepts/evolutions",title:"Schema evolution",description:"Evolutions are a relatively advanced concept in Flow.",source:"@site/docs/concepts/evolutions.md",sourceDirName:"concepts",slug:"/concepts/evolutions",permalink:"/pr-preview/pr-1259/concepts/evolutions",draft:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/concepts/evolutions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Task shards",permalink:"/pr-preview/pr-1259/concepts/advanced/shards"},next:{title:"Connectors",permalink:"/pr-preview/pr-1259/reference/Connectors/"}},c={};(0,n.kt)(i.Z,{chart:"\n  graph LR;\n    Source[Source System]--\x3eCapture;\n\t\tCapture--\x3eCollection;\n    Collection--\x3eMaterialization;\n    Materialization--\x3eDest[Destination System];\n"});const p=[{value:"Background",id:"background",level:2},{value:"What do evolutions do?",id:"what-do-evolutions-do",level:2},{value:"Evolutions in the UI",id:"evolutions-in-the-ui",level:2},{value:"Breaking schema changes",id:"breaking-schema-changes",level:2}],d={toc:p},u="wrapper";function h(e){let{components:t,...i}=e;return(0,n.kt)(u,(0,o.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"schema-evolution"},"Schema evolution"),(0,n.kt)("admonition",{type:"info"},(0,n.kt)("p",{parentName:"admonition"},"Evolutions are a relatively advanced concept in Flow.\nBefore continuing, you should have a basic understanding of ",(0,n.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/captures"},"Flow captures"),", ",(0,n.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/collections"},"collections"),", ",(0,n.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/schemas"},"schemas"),", and ",(0,n.kt)("a",{parentName:"p",href:"/pr-preview/pr-1259/concepts/materialization"},"materializations"),".")),(0,n.kt)("h2",{id:"background"},"Background"),(0,n.kt)("p",null,"To review, Flow collections are the realtime containers for your data, which sit in between captures and materializations."),(0,n.kt)("p",null,"Collection specs serve as a formal contract between producers (captures) and consumers (derivations and materializations) of data.\nThis contract encompasses the ",(0,n.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"schema")," (or ",(0,n.kt)("inlineCode",{parentName:"p"},"readSchema")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"writeSchema")," if defined separately), and logical partitioning of the collection. When any part of the contract changes, both the producers and consumers must approve of the change. If any party rejects the proposed change, Flow will fail the publication with an error. Evolutions are a feature that updates your draft to allow such a publication to proceed."),(0,n.kt)("p",null,"Collection specs may change for a huge variety of reasons, such as:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The source system is a database, and someone ran an ",(0,n.kt)("inlineCode",{parentName:"li"},"ALTER TABLE")," statement on a captured table."),(0,n.kt)("li",{parentName:"ul"},"The source system contains unstructured data, and some data with a different shape was just captured."),(0,n.kt)("li",{parentName:"ul"},"Someone manually published a change to the collection's logical partitions.")),(0,n.kt)("p",null,"Regardless of why or how a spec change is introduced, the effect is the same. Flow will never knowingly permit you to publish changes that break the contract between producers and consumers of a collection."),(0,n.kt)("h2",{id:"what-do-evolutions-do"},"What do evolutions do?"),(0,n.kt)("p",null,"Evolutions operations that update a draft. Evolutions don't do anything that you couldn't do yourself by editing specs directly. They just make it easier to handle common and repetitive scenarios. They can update drafts in two ways:"),(0,n.kt)("p",null,"Update materialization bindings to materialize a collection into a new resource (database table, for example): Any materializations of the evolving collection will be updated to materialize it into a new resource (database table, for example). For example, if the collection was previously materialized into a table called ",(0,n.kt)("inlineCode",{parentName:"p"},"my_table"),", the evolution would update it to instead materialize into ",(0,n.kt)("inlineCode",{parentName:"p"},"my_table_v2"),". The Flow collection itself remains unchanged."),(0,n.kt)("p",null,"Re-create the Flow collection with a new name: This creates a completely new collection with a ",(0,n.kt)("inlineCode",{parentName:"p"},"_v2")," (",(0,n.kt)("inlineCode",{parentName:"p"},"_v3"),", etc) suffix, which will start out empty and will need to backfill from the source. All Captures and materializations that reference the old collection will be updated to instead reference the new collection. This will also update any materializations to materialize the new collection into a new resource."),(0,n.kt)("admonition",{type:"info"},(0,n.kt)("p",{parentName:"admonition"},"Evolutions will soon support additional operations to re-create materialization resources (e.g. tables) while keeping the same names.")),(0,n.kt)("p",null,"In most common cases, evolutions will only need to update materialization bindings. Evolutions will always try to avoid re-creating the collection if at all possible. Collections will only be re-created in cases where the key or logical partitioning have changed. The remaining cases are due to changes to the collection schema. For example, perhaps a field has changed from ",(0,n.kt)("inlineCode",{parentName:"p"},"type: string")," to ",(0,n.kt)("inlineCode",{parentName:"p"},"type: integer"),", which results in a database materialization rejecting the change. In those cases, it's usually sufficient to materialize the collection into a new table."),(0,n.kt)("h2",{id:"evolutions-in-the-ui"},"Evolutions in the UI"),(0,n.kt)("p",null,"When you attempt to publish a breaking change to a collection via the UI, you'll get an error message that looks similar to this one:"),(0,n.kt)("p",null,(0,n.kt)("img",{src:a(1475).Z,width:"2498",height:"862"})),(0,n.kt)("p",null,"If you click the \"Apply\" button, then it will trigger an evolution, which updates your draft. You'll then be able to review and publish your draft, which should succeed now that you've handled all the breaking changes."),(0,n.kt)("h2",{id:"breaking-schema-changes"},"Breaking schema changes"),(0,n.kt)("p",null,"Changes to the collection ",(0,n.kt)("inlineCode",{parentName:"p"},"key")," or logical partition can happen, but in practice they tend to not be as common. The most common cause of a breaking change is just a change to the collection schema itself. Generally, it's the Materializations, not the Captures, that will complain about breaking schema changes. This is because the new collection specs are discovered by introspecting the data source, or else the collection uses schema inference and you just have to accept whatever came from the source. (TODO: awkward wording here) In any case, changes typically flow from the data sources toward the destinations."),(0,n.kt)("p",null,"Consider an example materialization of a collection that looks like this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"schema:\n  type: object\n  properties:\n    id: { type: integer }\n    foo: { type: string, format: date-time }\n  required: [id]\nkey: [/id]\n")),(0,n.kt)("p",null,"If you materialized that collection into a relational database table, the table would look something like ",(0,n.kt)("inlineCode",{parentName:"p"},"my_table (id integer primary key, foo timestamptz)"),"."),(0,n.kt)("p",null,"Now say you create a draft where you update the collection spec to remove ",(0,n.kt)("inlineCode",{parentName:"p"},"format: date-time")," from ",(0,n.kt)("inlineCode",{parentName:"p"},"bar"),". You'd expect the resulting table to then look like ",(0,n.kt)("inlineCode",{parentName:"p"},"(id integer primary key, foo text)"),". But since the column type of ",(0,n.kt)("inlineCode",{parentName:"p"},"foo")," has changed, this will fail when you try to publish your draft. An easy solution in this case would be to change the name of the table that the collection is materialized into. A common convention, which is used by evolutions, is to suffix the table name with ",(0,n.kt)("inlineCode",{parentName:"p"},"_v2"),", or increment the suffix if one is already present. Thus you'd end up with ",(0,n.kt)("inlineCode",{parentName:"p"},"my_table_v2 (id integer primary key, foo text)"),"."))}h.isMDXComponent=!0},1748:(e,t,a)=>{var o={"./locale":9234,"./locale.js":9234};function n(e){var t=i(e);return a(t)}function i(e){if(!a.o(o,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return o[e]}n.keys=function(){return Object.keys(o)},n.resolve=i,e.exports=n,n.id=1748},1475:(e,t,a)=>{"use strict";a.d(t,{Z:()=>o});const o=a.p+"assets/images/ui-evolution-re-create-de574ca2333327fc911cc8ff0e46c5b9.png"}}]);